// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AgreementFilter agreement filter
//
// swagger:model AgreementFilter
type AgreementFilter struct {

	// agreement ids
	AgreementIds []int32 `json:"AgreementIds"`

	// agreement types
	AgreementTypes []string `json:"AgreementTypes"`

	// end date from
	// Format: date-time
	EndDateFrom strfmt.DateTime `json:"EndDateFrom,omitempty"`

	// end date to
	// Format: date-time
	EndDateTo strfmt.DateTime `json:"EndDateTo,omitempty"`

	// organization Id
	OrganizationID int32 `json:"OrganizationId,omitempty"`

	// organization ids
	OrganizationIds []int32 `json:"OrganizationIds"`

	// page
	Page int32 `json:"Page,omitempty"`

	// page size
	PageSize int32 `json:"PageSize,omitempty"`

	// pricelist ids
	PricelistIds []int32 `json:"PricelistIds"`

	// program ids
	ProgramIds []int32 `json:"ProgramIds"`

	// publisher Id
	PublisherID int32 `json:"PublisherId,omitempty"`

	// publisher ids
	PublisherIds []int32 `json:"PublisherIds"`

	// sales price currency
	SalesPriceCurrency string `json:"SalesPriceCurrency,omitempty"`

	// search
	Search string `json:"Search,omitempty"`

	// search date
	// Format: date-time
	SearchDate strfmt.DateTime `json:"SearchDate,omitempty"`

	// status
	// Enum: [None Active Inactive ActiveInactive]
	Status string `json:"Status,omitempty"`

	// term required
	TermRequired bool `json:"TermRequired,omitempty"`
}

// Validate validates this agreement filter
func (m *AgreementFilter) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAgreementTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDateFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDateTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSearchDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var agreementFilterAgreementTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","LicenseAgreement","OpenAgreement","FrameAgreement","SamAgreement","ConsultingAgreement","CloudSeatAgreement","CloudUsageAgreement","ReportingAgreement","OtherAgreement","Reserved1","Reserved2","Reserved3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		agreementFilterAgreementTypesItemsEnum = append(agreementFilterAgreementTypesItemsEnum, v)
	}
}

func (m *AgreementFilter) validateAgreementTypesItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, agreementFilterAgreementTypesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AgreementFilter) validateAgreementTypes(formats strfmt.Registry) error {

	if swag.IsZero(m.AgreementTypes) { // not required
		return nil
	}

	for i := 0; i < len(m.AgreementTypes); i++ {

		// value enum
		if err := m.validateAgreementTypesItemsEnum("AgreementTypes"+"."+strconv.Itoa(i), "body", m.AgreementTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *AgreementFilter) validateEndDateFrom(formats strfmt.Registry) error {

	if swag.IsZero(m.EndDateFrom) { // not required
		return nil
	}

	if err := validate.FormatOf("EndDateFrom", "body", "date-time", m.EndDateFrom.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AgreementFilter) validateEndDateTo(formats strfmt.Registry) error {

	if swag.IsZero(m.EndDateTo) { // not required
		return nil
	}

	if err := validate.FormatOf("EndDateTo", "body", "date-time", m.EndDateTo.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AgreementFilter) validateSearchDate(formats strfmt.Registry) error {

	if swag.IsZero(m.SearchDate) { // not required
		return nil
	}

	if err := validate.FormatOf("SearchDate", "body", "date-time", m.SearchDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var agreementFilterTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","Active","Inactive","ActiveInactive"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		agreementFilterTypeStatusPropEnum = append(agreementFilterTypeStatusPropEnum, v)
	}
}

const (

	// AgreementFilterStatusNone captures enum value "None"
	AgreementFilterStatusNone string = "None"

	// AgreementFilterStatusActive captures enum value "Active"
	AgreementFilterStatusActive string = "Active"

	// AgreementFilterStatusInactive captures enum value "Inactive"
	AgreementFilterStatusInactive string = "Inactive"

	// AgreementFilterStatusActiveInactive captures enum value "ActiveInactive"
	AgreementFilterStatusActiveInactive string = "ActiveInactive"
)

// prop value enum
func (m *AgreementFilter) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, agreementFilterTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AgreementFilter) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("Status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AgreementFilter) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AgreementFilter) UnmarshalBinary(b []byte) error {
	var res AgreementFilter
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
